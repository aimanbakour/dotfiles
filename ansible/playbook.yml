---
- hosts: all
  gather_facts: true
  become: true
  vars:
    user: "{{ ansible_env.SUDO_USER | default(ansible_user_id) }}"
    # Simpler Jinja (no ternary filter) to avoid old Jinja/Ansible issues
    home: "{{ '/root' if user == 'root' else ('/home/' + user) }}"
    # Adjust for macOS or other OSes if needed
    # home: "{{ ansible_env.HOME | default(home) }}"

    apt_packages:
      - zsh
      - tmux
      - git
      - sudo
      - locales
      - ripgrep
      - fd-find
      - zoxide
      - zsh-syntax-highlighting
      - zsh-autosuggestions
      - build-essential
      - procps
      - file
      - jq
      - htop
      - p7zip-full
      - imagemagick
      - poppler-utils
      - curl
      - stow
      - xclip

    # Locale configuration
    locale_lang: "en_US.UTF-8"
    locale_generate:
      - "en_US.UTF-8 UTF-8"

    # Where this repo is on the target machine
    dotfiles_dir: "{{ home }}/dotfiles"

    # Sudo configuration
    sudo_group: sudo # Debian/Ubuntu default; adjust for other distros
    sudo_nopasswd: true # Always configure passwordless sudo by default

    # Packages to stow with their targets
    stow_map:
      - { name: "zsh", target: "{{ home }}/.config/zsh" }
      - { name: "nvim", target: "{{ home }}/.config/nvim" }
      - { name: "tmux", target: "{{ home }}/.config/tmux" }
      - { name: "starship", target: "{{ home }}/.config" }
      - { name: "yazi", target: "{{ home }}/.config/yazi" }
      - { name: "scripts", target: "{{ home }}/.local/scripts" }

    # Yazi install settings (Debian/Ubuntu: install official binary)
    install_yazi: true
    # Prefer musl build to avoid GLIBC version mismatches on older distros
    yazi_libc: musl # musl | gnu
    # Neovim install settings (install official binary)
    install_neovim: true
    # eza install settings (via Cargo)
    install_eza: true
    rust_profile: minimal
    # Molten (Neovim notebooks) venv via uv
    install_molten: true
    molten_venv_dir: "{{ home }}/.local/virtualenvs"
    molten_venv_name: ".neovim"
    molten_venv_path: "{{ molten_venv_dir }}/{{ molten_venv_name }}"

  tasks:
    - name: Ensure user exists (for container scenarios)
      user:
        name: "{{ user }}"
        shell: /usr/bin/zsh
        create_home: true
      tags: [user]

    - name: Install base packages (Debian/Ubuntu)
      apt:
        name: "{{ apt_packages }}"
        state: present
        update_cache: true
        cache_valid_time: 3600
      tags: [packages]

    # Locale setup (UTF-8)
    - name: Uncomment en_US.UTF-8 in /etc/locale.gen if present
      replace:
        path: /etc/locale.gen
        regexp: '^[#[:space:]]*en_US\.UTF-8 UTF-8$'
        replace: "en_US.UTF-8 UTF-8"
      tags: [locale]

    - name: Ensure en_US.UTF-8 line present in /etc/locale.gen
      lineinfile:
        path: /etc/locale.gen
        line: "en_US.UTF-8 UTF-8"
        state: present
        create: true
      tags: [locale]

    - name: Generate locales
      command: locale-gen
      changed_when: false
      tags: [locale]

    - name: Persist LANG and LC_ALL in /etc/default/locale
      lineinfile:
        path: /etc/default/locale
        create: true
        regexp: "^{{ item.key }}="
        line: "{{ item.key }}={{ item.val }}"
      loop:
        - { key: "LANG", val: "{{ locale_lang }}" }
        - { key: "LC_ALL", val: "{{ locale_lang }}" }
      tags: [locale]

    - name: Persist LANG and LC_ALL in /etc/environment
      lineinfile:
        path: /etc/environment
        create: true
        regexp: "^{{ item.key }}="
        line: "{{ item.key }}={{ item.val }}"
      loop:
        - { key: "LANG", val: "{{ locale_lang }}" }
        - { key: "LC_ALL", val: "{{ locale_lang }}" }
      tags: [locale]

    - name: Ensure user is in sudoers group
      user:
        name: "{{ user }}"
        groups: "{{ sudo_group }}"
        append: true
      tags: [sudo]

    - name: Configure passwordless sudo for the user (optional)
      copy:
        dest: "/etc/sudoers.d/99-{{ user }}"
        content: "{{ user }} ALL=(ALL:ALL) NOPASSWD:ALL\n"
        owner: root
        group: root
        mode: "0440"
        validate: "visudo -cf %s"
      when: sudo_nopasswd | bool
      tags: [sudo]

    - name: Symlink fd to fdfind for convenience
      file:
        src: /usr/bin/fdfind
        dest: /usr/local/bin/fd
        state: link
      when: ansible_facts['os_family'] == 'Debian'
      ignore_errors: true
      tags: [packages]

    - name: Ensure tools for Yazi binary install
      apt:
        name:
          - curl
          - jq
          - xz-utils
          - unzip
        state: present
        update_cache: true
        cache_valid_time: 3600
      when: install_yazi
      tags: [yazi, packages]

    # eza via Cargo (Rust)
    - name: Install build deps for Rust/Cargo (for eza)
      apt:
        name:
          - build-essential
          - pkg-config
          - cmake
          - libssl-dev
          - zlib1g-dev
        state: present
        update_cache: true
        cache_valid_time: 3600
      when: install_eza
      tags: [eza, packages]

    - name: Install rustup for user if missing (for eza)
      become_user: "{{ user }}"
      shell: |
        set -e
        curl https://sh.rustup.rs -sSf | sh -s -- -y --profile {{ rust_profile }}
      args:
        creates: "{{ home }}/.cargo/bin/rustup"
      when: install_eza
      tags: [eza]

    - name: Ensure cargo in PATH for this run (for eza)
      set_fact:
        cargo_bin: "{{ home }}/.cargo/bin"
      when: install_eza
      tags: [eza]

    - name: Install eza via Cargo
      become_user: "{{ user }}"
      shell: |
        set -e
        export PATH="{{ cargo_bin }}:$PATH"
        cargo install --locked eza
      args:
        executable: /bin/bash
        creates: "{{ home }}/.cargo/bin/eza"
      when: install_eza
      tags: [eza]

    - name: Link eza binary into /usr/local/bin
      file:
        src: "{{ home }}/.cargo/bin/eza"
        dest: "/usr/local/bin/eza"
        state: link
        force: true
      when: install_eza
      tags: [eza]

    # Neovim (official binary)
    - name: Detect CPU arch for Neovim (dpkg)
      command: dpkg --print-architecture
      register: nvim_arch_raw
      changed_when: false
      when: install_neovim
      tags: [neovim]

    - name: Map arch to Neovim AppImage arch
      set_fact:
        nvim_arch: "{{ 'x86_64' if nvim_arch_raw.stdout.strip() == 'amd64' else ('arm64' if nvim_arch_raw.stdout.strip() in ['arm64','aarch64'] else '') }}"
      when: install_neovim
      tags: [neovim]

    - name: Fail if Neovim arch is unsupported
      fail:
        msg: "Unsupported architecture for Neovim AppImage: {{ nvim_arch_raw.stdout.strip() }}"
      when: install_neovim and nvim_arch == ''
      tags: [neovim]

    - name: Build Neovim latest AppImage URL
      set_fact:
        nvim_appimage_url: "https://github.com/neovim/neovim/releases/latest/download/nvim-linux-{{ nvim_arch }}.appimage"
      when: install_neovim
      tags: [neovim]

    - name: Download Neovim AppImage
      get_url:
        url: "{{ nvim_appimage_url }}"
        dest: "/tmp/nvim-linux-{{ nvim_arch }}.appimage"
        mode: "0755"
        force: true
      when: install_neovim
      tags: [neovim]

    - name: Create Neovim AppImage install dir
      file:
        path: "/usr/local/nvim-appimage"
        state: directory
        mode: "0755"
      when: install_neovim
      tags: [neovim]

    - name: Extract Neovim AppImage (no FUSE required)
      shell: |
        set -e
        cd /usr/local/nvim-appimage
        rm -rf squashfs-root
        "/tmp/nvim-linux-{{ nvim_arch }}.appimage" --appimage-extract
      args:
        executable: /bin/bash
        creates: "/usr/local/nvim-appimage/squashfs-root/usr/bin/nvim"
      when: install_neovim
      tags: [neovim]

    - name: Ensure /usr/local/bin/nvim symlink
      file:
        src: "/usr/local/nvim-appimage/squashfs-root/usr/bin/nvim"
        dest: "/usr/local/bin/nvim"
        state: link
        force: true
      when: install_neovim
      tags: [neovim]

    - name: Detect CPU arch (dpkg)
      command: dpkg --print-architecture
      register: arch_raw
      changed_when: false
      when: install_yazi
      tags: [yazi]

    - name: Map arch to yazi arch
      set_fact:
        yazi_arch: "{{ 'x86_64' if arch_raw.stdout.strip() == 'amd64' else ('aarch64' if arch_raw.stdout.strip() in ['arm64','aarch64'] else arch_raw.stdout.strip()) }}"
      when: install_yazi
      tags: [yazi]

    - name: Build Yazi asset pattern and URL
      shell: |
        set -e
        arch='{{ yazi_arch }}'
        libc='{{ yazi_libc }}'
        api='https://api.github.com/repos/sxyazi/yazi/releases/latest'
        # Find first matching asset for arch + unknown-linux-<libc>
        url=$(curl -fsSL "$api" | jq -r ".assets[] | select((.name | test(\"$arch-unknown-linux-$libc\"))) | .browser_download_url" | head -n1)
        if [ -z "$url" ]; then
          echo ""; exit 1
        fi
        echo "$url"
      register: yazi_url
      changed_when: false
      failed_when: yazi_url.stdout == ""
      when: install_yazi
      tags: [yazi]

    - name: Determine Yazi archive extension
      set_fact:
        yazi_ext: "{{ (yazi_url.stdout | regex_search('\\.(tar\\.xz|tar\\.gz|zip)$')) or '.tar.gz' }}"
      when: install_yazi
      tags: [yazi]

    - name: Download Yazi archive
      get_url:
        url: "{{ yazi_url.stdout }}"
        dest: "/tmp/yazi-{{ yazi_arch }}{{ yazi_ext }}"
        force: true
      when: install_yazi
      tags: [yazi]

    - name: Create temporary extract dir
      file:
        path: "/tmp/yazi-extract"
        state: directory
        mode: "0755"
      when: install_yazi
      tags: [yazi]

    - name: Extract Yazi archive
      shell: |
        set -e
        file="/tmp/yazi-{{ yazi_arch }}{{ yazi_ext }}"
        case "$file" in
          *.tar.xz) tar -xJf "$file" -C /tmp/yazi-extract ;;
          *.tar.gz) tar -xzf "$file" -C /tmp/yazi-extract ;;
          *.zip)    unzip -o "$file" -d /tmp/yazi-extract ;;
          *)        tar -xf "$file" -C /tmp/yazi-extract ;;
        esac
      args:
        executable: /bin/bash
      when: install_yazi
      tags: [yazi]

    - name: Install Yazi binaries to /usr/local/bin
      shell: |
        set -e
        shopt -s globstar nullglob
        dest="/usr/local/bin"
        mkdir -p "$dest"
        # Install main binary 'yazi' and possible helpers 'ya*'
        installed=0
        for f in /tmp/yazi-extract/**/yazi /tmp/yazi-extract/**/ya /tmp/yazi-extract/**/yazi-*; do
          if [ -f "$f" ] && [ -x "$f" ]; then
            cp -f "$f" "$dest/$(basename "$f")"
            chmod 0755 "$dest/$(basename "$f")"
            installed=1
          fi
        done
        if [ "$installed" -eq 0 ]; then
          echo "No yazi binaries found in extracted archive" >&2
          exit 1
        fi
      args:
        executable: /bin/bash
      when: install_yazi
      tags: [yazi]

    - name: Cleanup temp Yazi files
      file:
        path: "/tmp/yazi-extract"
        state: absent
      when: install_yazi
      tags: [yazi]

    - name: Ensure key config/cache directories exist
      file:
        path: "{{ item }}"
        state: directory
        owner: "{{ user }}"
        group: "{{ user }}"
        mode: "0755"
      loop:
        - "{{ home }}/.config"
        - "{{ home }}/.cache/zsh"
        - "{{ home }}/.local/share/zsh"
      tags: [directories, zsh]

    - name: Copy wrapper .zshrc into $HOME
      copy:
        dest: "{{ home }}/.zshrc"
        content: |
          export ZDOTDIR="$HOME/.config/zsh"
          [ -f "$ZDOTDIR/.zshrc" ] && source "$ZDOTDIR/.zshrc"
        owner: "{{ user }}"
        group: "{{ user }}"
        mode: "0644"
      tags: [zsh]

    - name: Copy wrapper .zprofile into $HOME
      copy:
        dest: "{{ home }}/.zprofile"
        content: |
          export ZDOTDIR="$HOME/.config/zsh"
          [ -f "$ZDOTDIR/.zprofile" ] && source "$ZDOTDIR/.zprofile"
        owner: "{{ user }}"
        group: "{{ user }}"
        mode: "0644"
      tags: [zsh]

    - name: Ensure dotfiles repo exists at {{ dotfiles_dir }}
      git:
        repo: "https://github.com/aimanbakour/dotfiles"
        dest: "{{ dotfiles_dir }}"
        update: yes
        version: main
      become_user: "{{ user }}"
      tags: [dotfiles]

    - name: Ensure stow targets exist
      file:
        path: "{{ item.target }}"
        state: directory
        owner: "{{ user }}"
        group: "{{ user }}"
        mode: "0755"
      loop: "{{ stow_map }}"
      tags: [stow]

    - name: Install fzf-tab plugin (clone)
      git:
        repo: "https://github.com/Aloxaf/fzf-tab.git"
        dest: "{{ home }}/.local/share/zsh/fzf-tab"
        update: yes
        version: master
      become_user: "{{ user }}"
      tags: [plugins, zsh]

    - name: Stow dotfiles packages
      command: >-
        stow --restow --target="{{ item.target }}" {{ item.name }}
      args:
        chdir: "{{ dotfiles_dir }}"
      become_user: "{{ user }}"
      loop: "{{ stow_map }}"
      tags: [stow]

    - name: Ensure legacy tmux config symlink (~/.tmux.conf)
      file:
        src: "{{ home }}/.config/tmux/tmux.conf"
        dest: "{{ home }}/.tmux.conf"
        state: link
        owner: "{{ user }}"
        group: "{{ user }}"
        force: true
      tags: [tmux]

    - name: Set login shell to zsh (if not already)
      user:
        name: "{{ user }}"
        shell: /usr/bin/zsh
      tags: [zsh]

    - name: Install Starship (official script) if missing
      shell: |
        set -e
        curl -fsSL https://starship.rs/install.sh | sh -s -- -y -b /usr/local/bin
      args:
        creates: /usr/local/bin/starship
      tags: [packages, starship]
    - name: Install uv (official script) if missing
      become_user: "{{ user }}"
      shell: |
        set -e
        curl -LsSf https://astral.sh/uv/install.sh | sh
      args:
        executable: /bin/bash
        creates: "{{ home }}/.local/bin/uv"
      tags: [packages, uv]
    - name: Install Homebrew on Linux (if missing)
      become_user: "{{ user }}"
      shell: |
        set -e
        NONINTERACTIVE=1 /bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"
      args:
        executable: /bin/bash
        creates: "/home/linuxbrew/.linuxbrew/bin/brew"
      when: ansible_system == 'Linux'
      tags: [packages, brew]

    - name: Install fzf via Homebrew (Linux)
      become_user: "{{ user }}"
      shell: |
        set -e
        /home/linuxbrew/.linuxbrew/bin/brew install fzf
      args:
        executable: /bin/bash
        creates: "/home/linuxbrew/.linuxbrew/bin/fzf"
      when: ansible_system == 'Linux'
      tags: [packages, brew, fzf]
    - name: Ensure molten venv root exists
      file:
        path: "{{ molten_venv_dir }}"
        state: directory
        owner: "{{ user }}"
        group: "{{ user }}"
        mode: "0755"
      when: install_molten
      tags: [molten, neovim, python]

    - name: Create Neovim molten venv with uv
      become_user: "{{ user }}"
      shell: |
        set -e
        cd "{{ molten_venv_dir }}"
        uv venv "{{ molten_venv_name }}"
      args:
        executable: /bin/bash
        creates: "{{ molten_venv_path }}/bin/python"
      when: install_molten
      tags: [molten, neovim, python]

    - name: Install Python packages into molten venv
      become_user: "{{ user }}"
      pip:
        name:
          - pynvim
          - jupyter-client
        state: present
        executable: "{{ molten_venv_path }}/bin/pip"
      when: install_molten
      tags: [molten, neovim, python]

    - name: Final message
      debug:
        msg: |
          Dotfiles stowed. Open a new shell or run: exec zsh -l
      tags: [info]
